#!/usr/bin/env python
"""
Script completo para configura√ß√£o WAHA baseado na documenta√ß√£o oficial

Este script implementa o processo completo conforme a documenta√ß√£o:
1. Verifica√ß√£o do servidor WAHA
2. Cria√ß√£o/inicializa√ß√£o da sess√£o 
3. Obten√ß√£o do QR code
4. Monitoramento do status at√© WORKING
5. Teste de envio de mensagem

Documenta√ß√£o de refer√™ncia: https://waha.devlike.pro/docs/overview/quick-start/
"""

import os
import sys
import json
import time
import requests
import logging
from datetime import datetime
from typing import Dict, Any, Optional, List

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("waha_setup_complete")


class WAHASetup:
    """Classe para configura√ß√£o completa do WAHA seguindo a documenta√ß√£o oficial"""
    
    def __init__(self, 
                 base_url: str = "http://localhost:3000",
                 api_key: str = "zf-portal-api-key",
                 session_name: str = "default"):
        """
        Inicializa a configura√ß√£o WAHA
        
        Args:
            base_url: URL base do servidor WAHA
            api_key: Chave API (pode ser None para vers√£o Core)
            session_name: Nome da sess√£o
        """
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.session_name = session_name
        self.headers = {
            "Content-Type": "application/json"
        }
        
        # Adiciona API key se fornecida
        if self.api_key:
            self.headers["X-API-Key"] = self.api_key
    
    def check_server_health(self) -> bool:
        """
        Verifica se o servidor WAHA est√° funcionando
        
        Returns:
            bool: True se o servidor estiver dispon√≠vel
        """
        try:
            # Tenta acessar a p√°gina principal
            response = requests.get(f"{self.base_url}/", timeout=10)
            if response.status_code == 200:
                logger.info("‚úÖ Servidor WAHA est√° dispon√≠vel")
                return True
                
            # Se falhar, tenta a API diretamente
            response = requests.get(f"{self.base_url}/api/sessions", 
                                  headers=self.headers, timeout=10)
            if response.status_code == 200:
                logger.info("‚úÖ API WAHA est√° dispon√≠vel")
                return True
                
            logger.error(f"‚ùå Servidor WAHA n√£o responde: {response.status_code}")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao conectar com servidor WAHA: {e}")
            return False
    
    def list_sessions(self) -> List[Dict]:
        """
        Lista todas as sess√µes existentes
        
        Returns:
            List[Dict]: Lista de sess√µes
        """
        try:
            response = requests.get(f"{self.base_url}/api/sessions", 
                                  headers=self.headers)
            response.raise_for_status()
            
            sessions = response.json()
            logger.info(f"üìã Encontradas {len(sessions)} sess√£o(√µes)")
            
            for session in sessions:
                name = session.get('name', 'unknown')
                status = session.get('status', 'unknown')
                logger.info(f"  - {name}: {status}")
            
            return sessions
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao listar sess√µes: {e}")
            return []
    
    def get_session_info(self, session_name: str = None) -> Optional[Dict]:
        """
        Obt√©m informa√ß√µes de uma sess√£o espec√≠fica
        
        Args:
            session_name: Nome da sess√£o (usa self.session_name se None)
            
        Returns:
            Dict: Informa√ß√µes da sess√£o ou None se n√£o encontrada
        """
        if session_name is None:
            session_name = self.session_name
            
        try:
            response = requests.get(f"{self.base_url}/api/sessions/{session_name}", 
                                  headers=self.headers)
            
            if response.status_code == 404:
                logger.info(f"üì≠ Sess√£o '{session_name}' n√£o existe")
                return None
                
            response.raise_for_status()
            session_info = response.json()
            
            status = session_info.get('status', 'unknown')
            logger.info(f"üì± Sess√£o '{session_name}': {status}")
            
            return session_info
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao obter informa√ß√µes da sess√£o: {e}")
            return None
    
    def create_session(self, config: Dict = None) -> bool:
        """
        Cria uma nova sess√£o
        
        Args:
            config: Configura√ß√£o da sess√£o (opcional)
            
        Returns:
            bool: True se a sess√£o foi criada com sucesso
        """
        try:
            # Configura√ß√£o padr√£o para o Portal ZF
            default_config = {
                "name": self.session_name,
                "config": {
                    "webhooks": [
                        {
                            "url": "http://host.docker.internal:8000/api/v1/whatsapp/webhook",
                            "events": ["message", "session.status"]
                        }
                    ],
                    "debug": True,
                    "metadata": {
                        "project": "ZF Portal",
                        "environment": "development"
                    }
                }
            }
            
            # Usa a configura√ß√£o fornecida ou a padr√£o
            session_config = config or default_config
            
            logger.info(f"üîß Criando sess√£o '{self.session_name}'...")
            
            response = requests.post(f"{self.base_url}/api/sessions", 
                                   headers=self.headers, 
                                   json=session_config)
            response.raise_for_status()
            
            result = response.json()
            status = result.get('status', 'unknown')
            
            logger.info(f"‚úÖ Sess√£o criada com sucesso. Status: {status}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao criar sess√£o: {e}")
            return False
    
    def start_session(self) -> bool:
        """
        Inicia uma sess√£o existente
        
        Returns:
            bool: True se a sess√£o foi iniciada com sucesso
        """
        try:
            logger.info(f"‚ñ∂Ô∏è Iniciando sess√£o '{self.session_name}'...")
            
            response = requests.post(f"{self.base_url}/api/sessions/{self.session_name}/start", 
                                   headers=self.headers)
            response.raise_for_status()
            
            logger.info("‚úÖ Sess√£o iniciada com sucesso")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao iniciar sess√£o: {e}")
            return False
    
    def get_qr_code(self, save_path: str = None) -> bool:
        """
        Obt√©m e salva o QR code para autentica√ß√£o
        
        Args:
            save_path: Caminho para salvar o QR code (opcional)
            
        Returns:
            bool: True se o QR code foi obtido com sucesso
        """
        try:
            logger.info("üì± Obtendo QR code para autentica√ß√£o...")
            
            # Endpoint correto conforme documenta√ß√£o
            response = requests.get(f"{self.base_url}/api/{self.session_name}/auth/qr", 
                                  headers=self.headers)
            
            if response.status_code == 200:
                # Define o nome do arquivo se n√£o fornecido
                if save_path is None:
                    timestamp = int(time.time())
                    save_path = f"qr_code_{self.session_name}_{timestamp}.png"
                
                # Salva o QR code
                with open(save_path, 'wb') as f:
                    f.write(response.content)
                
                logger.info(f"üíæ QR Code salvo como: {save_path}")
                self._print_qr_instructions(save_path)
                return True
                
            elif response.status_code == 400:
                logger.warning("‚ö†Ô∏è QR code n√£o dispon√≠vel. Sess√£o pode j√° estar autenticada.")
                return False
                
            else:
                logger.error(f"‚ùå Erro ao obter QR code: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao obter QR code: {e}")
            return False
    
    def _print_qr_instructions(self, qr_path: str):
        """Imprime instru√ß√µes para usar o QR code"""
        print("\n" + "="*60)
        print("üì± INSTRU√á√ïES PARA AUTENTICA√á√ÉO WHATSAPP")
        print("="*60)
        print("1. Abra o WhatsApp no seu celular")
        print("2. V√° em Configura√ß√µes > Dispositivos conectados")
        print("3. Toque em 'Conectar um dispositivo'")
        print(f"4. Escaneie o QR code no arquivo: {qr_path}")
        print("5. Aguarde a confirma√ß√£o no terminal...")
        print("="*60)
    
    def wait_for_authentication(self, timeout: int = 120) -> bool:
        """
        Aguarda a autentica√ß√£o ser conclu√≠da
        
        Args:
            timeout: Tempo limite em segundos
            
        Returns:
            bool: True se a autentica√ß√£o foi bem-sucedida
        """
        logger.info(f"‚è≥ Aguardando autentica√ß√£o (timeout: {timeout}s)...")
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            session_info = self.get_session_info()
            
            if session_info:
                status = session_info.get('status', 'UNKNOWN')
                
                if status == 'WORKING':
                    me_info = session_info.get('me')
                    if me_info:
                        phone = me_info.get('id', 'N/A')
                        name = me_info.get('pushName', 'N/A')
                        logger.info(f"üéâ Autentica√ß√£o conclu√≠da!")
                        logger.info(f"üìû Telefone: {phone}")
                        logger.info(f"üë§ Nome: {name}")
                    else:
                        logger.info("‚úÖ Autentica√ß√£o conclu√≠da!")
                    return True
                    
                elif status == 'FAILED':
                    logger.error("‚ùå Falha na autentica√ß√£o")
                    return False
                    
                elif status == 'SCAN_QR_CODE':
                    logger.info("üì± Aguardando escaneamento do QR code...")
                    
                elif status == 'STARTING':
                    logger.info("üîÑ Inicializando sess√£o...")
                    
                else:
                    logger.info(f"üìä Status atual: {status}")
            
            time.sleep(5)
        
        logger.warning("‚è∞ Timeout na autentica√ß√£o")
        return False
    
    def send_test_message(self, phone_number: str = None, message: str = None) -> bool:
        """
        Envia uma mensagem de teste
        
        Args:
            phone_number: N√∫mero de telefone (formato: 5511999999999)
            message: Mensagem a ser enviada
            
        Returns:
            bool: True se a mensagem foi enviada com sucesso
        """
        if not phone_number:
            phone_number = input("üìû Digite o n√∫mero de telefone (formato: 5511999999999): ").strip()
        
        if not message:
            message = ("ü§ñ Teste de integra√ß√£o WAHA - Portal ZF\n\n"
                      "Esta √© uma mensagem de teste para verificar se a integra√ß√£o "
                      "est√° funcionando corretamente.\n\n"
                      f"Enviada em: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        
        try:
            logger.info(f"üí¨ Enviando mensagem de teste para {phone_number}...")
            
            # Formato correto do chatId conforme documenta√ß√£o
            chat_id = f"{phone_number}@c.us"
            
            data = {
                "chatId": chat_id,
                "text": message,
                "session": self.session_name
            }
            
            response = requests.post(f"{self.base_url}/api/sendText",
                                   headers=self.headers,
                                   json=data)
            response.raise_for_status()
            
            result = response.json()
            message_id = result.get('id', 'N/A')
            
            logger.info(f"‚úÖ Mensagem enviada com sucesso!")
            logger.info(f"üìß ID da mensagem: {message_id}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao enviar mensagem: {e}")
            return False
    
    def run_complete_setup(self) -> bool:
        """
        Executa o processo completo de configura√ß√£o
        
        Returns:
            bool: True se todo o processo foi bem-sucedido
        """
        print("üöÄ CONFIGURA√á√ÉO COMPLETA WAHA - PORTAL ZF")
        print("=" * 50)
        
        # 1. Verificar servidor
        print("\nüîç 1. Verificando servidor WAHA...")
        if not self.check_server_health():
            print("‚ùå Servidor WAHA n√£o est√° dispon√≠vel!")
            print("   Certifique-se de que o container est√° rodando:")
            print("   docker ps | findstr waha")
            return False
        
        # 2. Verificar sess√µes existentes
        print("\nüìã 2. Verificando sess√µes existentes...")
        sessions = self.list_sessions()
        
        # 3. Verificar se a sess√£o padr√£o existe
        print(f"\nüîç 3. Verificando sess√£o '{self.session_name}'...")
        session_info = self.get_session_info()
        
        if session_info is None:
            # Sess√£o n√£o existe, criar uma nova
            print(f"\nüîß 4. Criando nova sess√£o '{self.session_name}'...")
            if not self.create_session():
                return False
        else:
            status = session_info.get('status', 'UNKNOWN')
            if status == 'WORKING':
                logger.info("‚úÖ Sess√£o j√° est√° autenticada e funcionando!")
                return self._test_authenticated_session()
            elif status == 'STOPPED':
                logger.info("üîÑ Sess√£o existe mas est√° parada. Iniciando...")
                if not self.start_session():
                    return False
        
        # 4. Aguardar status SCAN_QR_CODE e obter QR
        print("\nüì± 4. Aguardando QR code...")
        max_attempts = 10
        for attempt in range(max_attempts):
            session_info = self.get_session_info()
            if session_info:
                status = session_info.get('status', 'UNKNOWN')
                
                if status == 'SCAN_QR_CODE':
                    logger.info("üì± Status SCAN_QR_CODE detectado. Obtendo QR code...")
                    if self.get_qr_code():
                        break
                    else:
                        logger.warning("Falha ao obter QR code, tentando novamente...")
                        
                elif status == 'WORKING':
                    logger.info("‚úÖ Sess√£o j√° est√° autenticada!")
                    return self._test_authenticated_session()
                    
                else:
                    logger.info(f"‚è≥ Aguardando status SCAN_QR_CODE... (atual: {status})")
            
            time.sleep(3)
        else:
            logger.error("‚ùå Timeout aguardando QR code")
            return False
        
        # 5. Aguardar autentica√ß√£o
        print("\nüîê 5. Aguardando autentica√ß√£o...")
        if not self.wait_for_authentication():
            logger.error("‚ùå Falha na autentica√ß√£o")
            return False
        
        # 6. Teste de funcionalidade
        return self._test_authenticated_session()
    
    def _test_authenticated_session(self) -> bool:
        """Testa a sess√£o autenticada"""
        print("\n‚úÖ 6. Sess√£o autenticada com sucesso!")
        
        # Teste opcional de envio de mensagem
        print("\nüí¨ 7. Teste de envio de mensagem (opcional)")
        test_message = input("Deseja testar o envio de uma mensagem? (s/N): ").strip().lower()
        
        if test_message == 's':
            return self.send_test_message()
        else:
            print("‚è≠Ô∏è Teste de mensagem pulado")
            
        print("\nüéâ Configura√ß√£o conclu√≠da com sucesso!")
        print("üîó O Portal ZF agora est√° integrado com o WhatsApp via WAHA")
        self._print_next_steps()
        return True
    
    def _print_next_steps(self):
        """Imprime os pr√≥ximos passos"""
        print("\nüìã PR√ìXIMOS PASSOS:")
        print("1. ‚úÖ Configure webhooks para recebimento de mensagens")
        print("2. ‚úÖ Implemente os fluxos de chatbot espec√≠ficos")
        print("3. ‚úÖ Configure templates de mensagens para campanhas")
        print("4. ‚úÖ Teste a integra√ß√£o completa com o Portal ZF")
        print("\nüîó URLs √∫teis:")
        print(f"   Dashboard: {self.base_url}/dashboard")
        print(f"   Swagger API: {self.base_url}/")


def main():
    """Fun√ß√£o principal"""
    try:
        # Configura√ß√£o baseada no ambiente atual
        setup = WAHASetup(
            base_url="http://localhost:3000",
            api_key="zf-portal-api-key",  # API key do container atual
            session_name="default"
        )
        
        success = setup.run_complete_setup()
        
        if not success:
            print("\n‚ùå Configura√ß√£o falhou. Verifique os logs para mais detalhes.")
            return 1
            
        return 0
        
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Configura√ß√£o cancelada pelo usu√°rio")
        return 1
    except Exception as e:
        logger.error(f"‚ùå Erro inesperado: {e}")
        return 1


if __name__ == "__main__":
    exit(main())
